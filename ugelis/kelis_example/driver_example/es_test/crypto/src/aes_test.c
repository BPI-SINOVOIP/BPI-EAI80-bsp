#include <ugelis.h>
#include <misc/util.h>
#include <misc/printk.h>
#include <gm_hal_crypto.h>


#define DMA_MODE_TEST   0

#define AES_ENCRYPT     1
#define AES_DECRYPT     0

static uint8_t INFIFO_TRANS_DONE = FALSE;
static uint8_t OUTFIFO_TRANS_DONE = FALSE;

/* AES ECB mode test data */
static const unsigned char aes_test_ecb_key[3][32] =
{
    {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    },
    {
        0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
        0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b
    },
    {
        0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
        0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
        0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
        0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4
    }
};

static const unsigned char aes_test_ecb_plaintext[64] =
{
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
    0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
    0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};

static const unsigned char aes_test_ecb_dec[3][64] =
{
    {
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
        0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d,
        0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
        0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23,
        0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
        0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f,
        0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
    },

    {
        0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f,
        0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc,
        0x97, 0x41, 0x04, 0x84, 0x6d, 0x0a, 0xd3, 0xad,
        0x77, 0x34, 0xec, 0xb3, 0xec, 0xee, 0x4e, 0xef,
        0xef, 0x7a, 0xfd, 0x22, 0x70, 0xe2, 0xe6, 0x0a,
        0xdc, 0xe0, 0xba, 0x2f, 0xac, 0xe6, 0x44, 0x4e,
        0x9a, 0x4b, 0x41, 0xba, 0x73, 0x8d, 0x6c, 0x72,
        0xfb, 0x16, 0x69, 0x16, 0x03, 0xc1, 0x8e, 0x0e
    },

    {
        0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c,
        0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8,
        0x59, 0x1c, 0xcb, 0x10, 0xd4, 0x10, 0xed, 0x26,
        0xdc, 0x5b, 0xa7, 0x4a, 0x31, 0x36, 0x28, 0x70,
        0xb6, 0xed, 0x21, 0xb9, 0x9c, 0xa6, 0xf4, 0xf9,
        0xf1, 0x53, 0xe7, 0xb1, 0xbe, 0xaf, 0xed, 0x1d,
        0x23, 0x30, 0x4b, 0x7a, 0x39, 0xf9, 0xf3, 0xff,
        0x06, 0x7d, 0x8d, 0x8f, 0x9e, 0x24, 0xec, 0xc7
    }
};

static const unsigned char aes_test_ecb_enc[3][64] =
{
    {
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
        0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d,
        0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,
        0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23,
        0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,
        0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f,
        0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4
    },

    {
        0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f,
        0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc,
        0x97, 0x41, 0x04, 0x84, 0x6d, 0x0a, 0xd3, 0xad,
        0x77, 0x34, 0xec, 0xb3, 0xec, 0xee, 0x4e, 0xef,
        0xef, 0x7a, 0xfd, 0x22, 0x70, 0xe2, 0xe6, 0x0a,
        0xdc, 0xe0, 0xba, 0x2f, 0xac, 0xe6, 0x44, 0x4e,
        0x9a, 0x4b, 0x41, 0xba, 0x73, 0x8d, 0x6c, 0x72,
        0xfb, 0x16, 0x69, 0x16, 0x03, 0xc1, 0x8e, 0x0e
    },

    {
        0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c,
        0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8,
        0x59, 0x1c, 0xcb, 0x10, 0xd4, 0x10, 0xed, 0x26,
        0xdc, 0x5b, 0xa7, 0x4a, 0x31, 0x36, 0x28, 0x70,
        0xb6, 0xed, 0x21, 0xb9, 0x9c, 0xa6, 0xf4, 0xf9,
        0xf1, 0x53, 0xe7, 0xb1, 0xbe, 0xaf, 0xed, 0x1d,
        0x23, 0x30, 0x4b, 0x7a, 0x39, 0xf9, 0xf3, 0xff,
        0x06, 0x7d, 0x8d, 0x8f, 0x9e, 0x24, 0xec, 0xc7
    }
};


/* AES CBC mode test data */
static const unsigned char aes_test_cbc_key[3][32] =
{
    {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    },
    {
        0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
        0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b
    },
    {
        0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
        0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
        0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
        0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4
    }
};

static const unsigned char aes_test_cbc_plaintext[64] =
{
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
    0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
    0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};

static const unsigned char aes_test_cbc_iv[16] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
};

static const unsigned char aes_test_cbc_dec[3][64] =
{
    {
        0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
        0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
        0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
        0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,
        0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b,
        0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,
        0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09,
        0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
    },

    {
        0x4f, 0x02, 0x1d, 0xb2, 0x43, 0xbc, 0x63, 0x3d,
        0x71, 0x78, 0x18, 0x3a, 0x9f, 0xa0, 0x71, 0xe8,
        0xb4, 0xd9, 0xad, 0xa9, 0xad, 0x7d, 0xed, 0xf4,
        0xe5, 0xe7, 0x38, 0x76, 0x3f, 0x69, 0x14, 0x5a,
        0x57, 0x1b, 0x24, 0x20, 0x12, 0xfb, 0x7a, 0xe0,
        0x7f, 0xa9, 0xba, 0xac, 0x3d, 0xf1, 0x02, 0xe0,
        0x08, 0xb0, 0xe2, 0x79, 0x88, 0x59, 0x88, 0x81,
        0xd9, 0x20, 0xa9, 0xe6, 0x4f, 0x56, 0x15, 0xcd
    },

    {
        0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba,
        0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
        0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d,
        0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
        0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf,
        0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
        0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc,
        0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b
    }
};

static const unsigned char aes_test_cbc_enc[3][64] =
{
    {
        0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
        0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
        0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
        0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,
        0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b,
        0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,
        0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09,
        0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7
    },

    {
        0x4f, 0x02, 0x1d, 0xb2, 0x43, 0xbc, 0x63, 0x3d,
        0x71, 0x78, 0x18, 0x3a, 0x9f, 0xa0, 0x71, 0xe8,
        0xb4, 0xd9, 0xad, 0xa9, 0xad, 0x7d, 0xed, 0xf4,
        0xe5, 0xe7, 0x38, 0x76, 0x3f, 0x69, 0x14, 0x5a,
        0x57, 0x1b, 0x24, 0x20, 0x12, 0xfb, 0x7a, 0xe0,
        0x7f, 0xa9, 0xba, 0xac, 0x3d, 0xf1, 0x02, 0xe0,
        0x08, 0xb0, 0xe2, 0x79, 0x88, 0x59, 0x88, 0x81,
        0xd9, 0x20, 0xa9, 0xe6, 0x4f, 0x56, 0x15, 0xcd
    },

    {
        0xf5, 0x8c, 0x4c, 0x04, 0xd6, 0xe5, 0xf1, 0xba,
        0x77, 0x9e, 0xab, 0xfb, 0x5f, 0x7b, 0xfb, 0xd6,
        0x9c, 0xfc, 0x4e, 0x96, 0x7e, 0xdb, 0x80, 0x8d,
        0x67, 0x9f, 0x77, 0x7b, 0xc6, 0x70, 0x2c, 0x7d,
        0x39, 0xf2, 0x33, 0x69, 0xa9, 0xd9, 0xba, 0xcf,
        0xa5, 0x30, 0xe2, 0x63, 0x04, 0x23, 0x14, 0x61,
        0xb2, 0xeb, 0x05, 0xe2, 0xc3, 0x9b, 0xe9, 0xfc,
        0xda, 0x6c, 0x19, 0x07, 0x8c, 0x6a, 0x9d, 0x1b
    }

};


/* AES CTR mode test data */
static const unsigned char aes_test_ctr_key[3][32] =
{
    {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    },
    {
        0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52,
        0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,
        0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b
    },
    {
        0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe,
        0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,
        0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7,
        0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4
    }
};

static const unsigned char aes_test_ctr_plaintext[64] =
{
    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
    0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
    0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
    0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10
};

static const unsigned char aes_test_ctr_nonce_counter[16] =
{
    0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

static const unsigned char aes_test_ctr_dec[3][64] =
{
    {
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee
    },

    {
        0x1a, 0xbc, 0x93, 0x24, 0x17, 0x52, 0x1c, 0xa2,
        0x4f, 0x2b, 0x04, 0x59, 0xfe, 0x7e, 0x6e, 0x0b,
        0x09, 0x03, 0x39, 0xec, 0x0a, 0xa6, 0xfa, 0xef,
        0xd5, 0xcc, 0xc2, 0xc6, 0xf4, 0xce, 0x8e, 0x94,
        0x1e, 0x36, 0xb2, 0x6b, 0xd1, 0xeb, 0xc6, 0x70,
        0xd1, 0xbd, 0x1d, 0x66, 0x56, 0x20, 0xab, 0xf7,
        0x4f, 0x78, 0xa7, 0xf6, 0xd2, 0x98, 0x09, 0x58,
        0x5a, 0x97, 0xda, 0xec, 0x58, 0xc6, 0xb0, 0x50
    },

    {
        0x60, 0x1e, 0xc3, 0x13, 0x77, 0x57, 0x89, 0xa5,
        0xb7, 0xa7, 0xf5, 0x04, 0xbb, 0xf3, 0xd2, 0x28,
        0xf4, 0x43, 0xe3, 0xca, 0x4d, 0x62, 0xb5, 0x9a,
        0xca, 0x84, 0xe9, 0x90, 0xca, 0xca, 0xf5, 0xc5,
        0x2b, 0x09, 0x30, 0xda, 0xa2, 0x3d, 0xe9, 0x4c,
        0xe8, 0x70, 0x17, 0xba, 0x2d, 0x84, 0x98, 0x8d,
        0xdf, 0xc9, 0xc5, 0x8d, 0xb6, 0x7a, 0xad, 0xa6,
        0x13, 0xc2, 0xdd, 0x08, 0x45, 0x79, 0x41, 0xa6
    }
};

static const unsigned char aes_test_ctr_enc[3][64] =
{
    {
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee
    },

    {
        0x1a, 0xbc, 0x93, 0x24, 0x17, 0x52, 0x1c, 0xa2,
        0x4f, 0x2b, 0x04, 0x59, 0xfe, 0x7e, 0x6e, 0x0b,
        0x09, 0x03, 0x39, 0xec, 0x0a, 0xa6, 0xfa, 0xef,
        0xd5, 0xcc, 0xc2, 0xc6, 0xf4, 0xce, 0x8e, 0x94,
        0x1e, 0x36, 0xb2, 0x6b, 0xd1, 0xeb, 0xc6, 0x70,
        0xd1, 0xbd, 0x1d, 0x66, 0x56, 0x20, 0xab, 0xf7,
        0x4f, 0x78, 0xa7, 0xf6, 0xd2, 0x98, 0x09, 0x58,
        0x5a, 0x97, 0xda, 0xec, 0x58, 0xc6, 0xb0, 0x50
    },

    {
        0x60, 0x1e, 0xc3, 0x13, 0x77, 0x57, 0x89, 0xa5,
        0xb7, 0xa7, 0xf5, 0x04, 0xbb, 0xf3, 0xd2, 0x28,
        0xf4, 0x43, 0xe3, 0xca, 0x4d, 0x62, 0xb5, 0x9a,
        0xca, 0x84, 0xe9, 0x90, 0xca, 0xca, 0xf5, 0xc5,
        0x2b, 0x09, 0x30, 0xda, 0xa2, 0x3d, 0xe9, 0x4c,
        0xe8, 0x70, 0x17, 0xba, 0x2d, 0x84, 0x98, 0x8d,
        0xdf, 0xc9, 0xc5, 0x8d, 0xb6, 0x7a, 0xad, 0xa6,
        0x13, 0xc2, 0xdd, 0x08, 0x45, 0x79, 0x41, 0xa6
    }
};


/* AES GCM mode test data */
#define MAX_TESTS   6

static const int key_index[MAX_TESTS] =
{ 0, 0, 1, 1, 1, 1 };

static const unsigned char key[MAX_TESTS][32] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08,
        0xfe, 0xff, 0xe9, 0x92, 0x86, 0x65, 0x73, 0x1c,
        0x6d, 0x6a, 0x8f, 0x94, 0x67, 0x30, 0x83, 0x08
    },
};

static const size_t iv_len[MAX_TESTS] =
{ 12, 12, 12, 12, 8, 60 };

static const int iv_index[MAX_TESTS] =
{ 0, 0, 1, 1, 1, 2 };

static const unsigned char iv[MAX_TESTS][64] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    },
    {
        0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
        0xde, 0xca, 0xf8, 0x88
    },
    {
        0x93, 0x13, 0x22, 0x5d, 0xf8, 0x84, 0x06, 0xe5,
        0x55, 0x90, 0x9c, 0x5a, 0xff, 0x52, 0x69, 0xaa,
        0x6a, 0x7a, 0x95, 0x38, 0x53, 0x4f, 0x7d, 0xa1,
        0xe4, 0xc3, 0x03, 0xd2, 0xa3, 0x18, 0xa7, 0x28,
        0xc3, 0xc0, 0xc9, 0x51, 0x56, 0x80, 0x95, 0x39,
        0xfc, 0xf0, 0xe2, 0x42, 0x9a, 0x6b, 0x52, 0x54,
        0x16, 0xae, 0xdb, 0xf5, 0xa0, 0xde, 0x6a, 0x57,
        0xa6, 0x37, 0xb3, 0x9b
    },
};

static const size_t add_len[MAX_TESTS] =
{ 0, 0, 0, 20, 20, 20 };

static const int add_index[MAX_TESTS] =
{ 0, 0, 0, 1, 1, 1 };

static const unsigned char additional[MAX_TESTS][64] =
{
    { 0x00 },
    {
        0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
        0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
        0xab, 0xad, 0xda, 0xd2
    },
};

static const size_t pt_len[MAX_TESTS] =
{ 0, 16, 64, 60, 60, 60 };

static const int pt_index[MAX_TESTS] =
{ 0, 0, 1, 1, 1, 1 };

static const unsigned char pt[MAX_TESTS][64] =
{
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
        0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
        0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
        0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
        0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
        0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
        0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
        0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
        0xba, 0x63, 0x7b, 0x39, 0x1a, 0xaf, 0xd2, 0x55
    },
};

static const unsigned char ct[MAX_TESTS * 3][64] =
{
    { 0x00 },
    {
        0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92,
        0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78
    },
    {
        0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,
        0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
        0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
        0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
        0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,
        0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
        0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,
        0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85
    },
    {
        0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,
        0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
        0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
        0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
        0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,
        0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
        0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,
        0x3d, 0x58, 0xe0, 0x91
    },
    {
        0x61, 0x35, 0x3b, 0x4c, 0x28, 0x06, 0x93, 0x4a,
        0x77, 0x7f, 0xf5, 0x1f, 0xa2, 0x2a, 0x47, 0x55,
        0x69, 0x9b, 0x2a, 0x71, 0x4f, 0xcd, 0xc6, 0xf8,
        0x37, 0x66, 0xe5, 0xf9, 0x7b, 0x6c, 0x74, 0x23,
        0x73, 0x80, 0x69, 0x00, 0xe4, 0x9f, 0x24, 0xb2,
        0x2b, 0x09, 0x75, 0x44, 0xd4, 0x89, 0x6b, 0x42,
        0x49, 0x89, 0xb5, 0xe1, 0xeb, 0xac, 0x0f, 0x07,
        0xc2, 0x3f, 0x45, 0x98
    },
    {
        0x8c, 0xe2, 0x49, 0x98, 0x62, 0x56, 0x15, 0xb6,
        0x03, 0xa0, 0x33, 0xac, 0xa1, 0x3f, 0xb8, 0x94,
        0xbe, 0x91, 0x12, 0xa5, 0xc3, 0xa2, 0x11, 0xa8,
        0xba, 0x26, 0x2a, 0x3c, 0xca, 0x7e, 0x2c, 0xa7,
        0x01, 0xe4, 0xa9, 0xa4, 0xfb, 0xa4, 0x3c, 0x90,
        0xcc, 0xdc, 0xb2, 0x81, 0xd4, 0x8c, 0x7c, 0x6f,
        0xd6, 0x28, 0x75, 0xd2, 0xac, 0xa4, 0x17, 0x03,
        0x4c, 0x34, 0xae, 0xe5
    },
    { 0x00 },
    {
        0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41,
        0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00
    },
    {
        0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41,
        0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,
        0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84,
        0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,
        0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,
        0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,
        0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9,
        0xcc, 0xda, 0x27, 0x10, 0xac, 0xad, 0xe2, 0x56
    },
    {
        0x39, 0x80, 0xca, 0x0b, 0x3c, 0x00, 0xe8, 0x41,
        0xeb, 0x06, 0xfa, 0xc4, 0x87, 0x2a, 0x27, 0x57,
        0x85, 0x9e, 0x1c, 0xea, 0xa6, 0xef, 0xd9, 0x84,
        0x62, 0x85, 0x93, 0xb4, 0x0c, 0xa1, 0xe1, 0x9c,
        0x7d, 0x77, 0x3d, 0x00, 0xc1, 0x44, 0xc5, 0x25,
        0xac, 0x61, 0x9d, 0x18, 0xc8, 0x4a, 0x3f, 0x47,
        0x18, 0xe2, 0x44, 0x8b, 0x2f, 0xe3, 0x24, 0xd9,
        0xcc, 0xda, 0x27, 0x10
    },
    {
        0x0f, 0x10, 0xf5, 0x99, 0xae, 0x14, 0xa1, 0x54,
        0xed, 0x24, 0xb3, 0x6e, 0x25, 0x32, 0x4d, 0xb8,
        0xc5, 0x66, 0x63, 0x2e, 0xf2, 0xbb, 0xb3, 0x4f,
        0x83, 0x47, 0x28, 0x0f, 0xc4, 0x50, 0x70, 0x57,
        0xfd, 0xdc, 0x29, 0xdf, 0x9a, 0x47, 0x1f, 0x75,
        0xc6, 0x65, 0x41, 0xd4, 0xd4, 0xda, 0xd1, 0xc9,
        0xe9, 0x3a, 0x19, 0xa5, 0x8e, 0x8b, 0x47, 0x3f,
        0xa0, 0xf0, 0x62, 0xf7
    },
    {
        0xd2, 0x7e, 0x88, 0x68, 0x1c, 0xe3, 0x24, 0x3c,
        0x48, 0x30, 0x16, 0x5a, 0x8f, 0xdc, 0xf9, 0xff,
        0x1d, 0xe9, 0xa1, 0xd8, 0xe6, 0xb4, 0x47, 0xef,
        0x6e, 0xf7, 0xb7, 0x98, 0x28, 0x66, 0x6e, 0x45,
        0x81, 0xe7, 0x90, 0x12, 0xaf, 0x34, 0xdd, 0xd9,
        0xe2, 0xf0, 0x37, 0x58, 0x9b, 0x29, 0x2d, 0xb3,
        0xe6, 0x7c, 0x03, 0x67, 0x45, 0xfa, 0x22, 0xe7,
        0xe9, 0xb7, 0x37, 0x3b
    },
    { 0x00 },
    {
        0xce, 0xa7, 0x40, 0x3d, 0x4d, 0x60, 0x6b, 0x6e,
        0x07, 0x4e, 0xc5, 0xd3, 0xba, 0xf3, 0x9d, 0x18
    },
    {
        0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07,
        0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,
        0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9,
        0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,
        0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,
        0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,
        0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a,
        0xbc, 0xc9, 0xf6, 0x62, 0x89, 0x80, 0x15, 0xad
    },
    {
        0x52, 0x2d, 0xc1, 0xf0, 0x99, 0x56, 0x7d, 0x07,
        0xf4, 0x7f, 0x37, 0xa3, 0x2a, 0x84, 0x42, 0x7d,
        0x64, 0x3a, 0x8c, 0xdc, 0xbf, 0xe5, 0xc0, 0xc9,
        0x75, 0x98, 0xa2, 0xbd, 0x25, 0x55, 0xd1, 0xaa,
        0x8c, 0xb0, 0x8e, 0x48, 0x59, 0x0d, 0xbb, 0x3d,
        0xa7, 0xb0, 0x8b, 0x10, 0x56, 0x82, 0x88, 0x38,
        0xc5, 0xf6, 0x1e, 0x63, 0x93, 0xba, 0x7a, 0x0a,
        0xbc, 0xc9, 0xf6, 0x62
    },
    {
        0xc3, 0x76, 0x2d, 0xf1, 0xca, 0x78, 0x7d, 0x32,
        0xae, 0x47, 0xc1, 0x3b, 0xf1, 0x98, 0x44, 0xcb,
        0xaf, 0x1a, 0xe1, 0x4d, 0x0b, 0x97, 0x6a, 0xfa,
        0xc5, 0x2f, 0xf7, 0xd7, 0x9b, 0xba, 0x9d, 0xe0,
        0xfe, 0xb5, 0x82, 0xd3, 0x39, 0x34, 0xa4, 0xf0,
        0x95, 0x4c, 0xc2, 0x36, 0x3b, 0xc7, 0x3f, 0x78,
        0x62, 0xac, 0x43, 0x0e, 0x64, 0xab, 0xe4, 0x99,
        0xf4, 0x7c, 0x9b, 0x1f
    },
    {
        0x5a, 0x8d, 0xef, 0x2f, 0x0c, 0x9e, 0x53, 0xf1,
        0xf7, 0x5d, 0x78, 0x53, 0x65, 0x9e, 0x2a, 0x20,
        0xee, 0xb2, 0xb2, 0x2a, 0xaf, 0xde, 0x64, 0x19,
        0xa0, 0x58, 0xab, 0x4f, 0x6f, 0x74, 0x6b, 0xf4,
        0x0f, 0xc0, 0xc3, 0xb7, 0x80, 0xf2, 0x44, 0x45,
        0x2d, 0xa3, 0xeb, 0xf1, 0xc5, 0xd8, 0x2c, 0xde,
        0xa2, 0x41, 0x89, 0x97, 0x20, 0x0e, 0xf8, 0x2e,
        0x44, 0xae, 0x7e, 0x3f
    },
};

static const unsigned char tag[MAX_TESTS * 3][16] =
{
    {
        0x58, 0xe2, 0xfc, 0xce, 0xfa, 0x7e, 0x30, 0x61,
        0x36, 0x7f, 0x1d, 0x57, 0xa4, 0xe7, 0x45, 0x5a
    },
    {
        0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd,
        0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf
    },
    {
        0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6,
        0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4
    },
    {
        0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,
        0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47
    },
    {
        0x36, 0x12, 0xd2, 0xe7, 0x9e, 0x3b, 0x07, 0x85,
        0x56, 0x1b, 0xe1, 0x4a, 0xac, 0xa2, 0xfc, 0xcb
    },
    {
        0x61, 0x9c, 0xc5, 0xae, 0xff, 0xfe, 0x0b, 0xfa,
        0x46, 0x2a, 0xf4, 0x3c, 0x16, 0x99, 0xd0, 0x50
    },
    {
        0xcd, 0x33, 0xb2, 0x8a, 0xc7, 0x73, 0xf7, 0x4b,
        0xa0, 0x0e, 0xd1, 0xf3, 0x12, 0x57, 0x24, 0x35
    },
    {
        0x2f, 0xf5, 0x8d, 0x80, 0x03, 0x39, 0x27, 0xab,
        0x8e, 0xf4, 0xd4, 0x58, 0x75, 0x14, 0xf0, 0xfb
    },
    {
        0x99, 0x24, 0xa7, 0xc8, 0x58, 0x73, 0x36, 0xbf,
        0xb1, 0x18, 0x02, 0x4d, 0xb8, 0x67, 0x4a, 0x14
    },
    {
        0x25, 0x19, 0x49, 0x8e, 0x80, 0xf1, 0x47, 0x8f,
        0x37, 0xba, 0x55, 0xbd, 0x6d, 0x27, 0x61, 0x8c
    },
    {
        0x65, 0xdc, 0xc5, 0x7f, 0xcf, 0x62, 0x3a, 0x24,
        0x09, 0x4f, 0xcc, 0xa4, 0x0d, 0x35, 0x33, 0xf8
    },
    {
        0xdc, 0xf5, 0x66, 0xff, 0x29, 0x1c, 0x25, 0xbb,
        0xb8, 0x56, 0x8f, 0xc3, 0xd3, 0x76, 0xa6, 0xd9
    },
    {
        0x53, 0x0f, 0x8a, 0xfb, 0xc7, 0x45, 0x36, 0xb9,
        0xa9, 0x63, 0xb4, 0xf1, 0xc4, 0xcb, 0x73, 0x8b
    },
    {
        0xd0, 0xd1, 0xc8, 0xa7, 0x99, 0x99, 0x6b, 0xf0,
        0x26, 0x5b, 0x98, 0xb5, 0xd4, 0x8a, 0xb9, 0x19
    },
    {
        0xb0, 0x94, 0xda, 0xc5, 0xd9, 0x34, 0x71, 0xbd,
        0xec, 0x1a, 0x50, 0x22, 0x70, 0xe3, 0xcc, 0x6c
    },
    {
        0x76, 0xfc, 0x6e, 0xce, 0x0f, 0x4e, 0x17, 0x68,
        0xcd, 0xdf, 0x88, 0x53, 0xbb, 0x2d, 0x55, 0x1b
    },
    {
        0x3a, 0x33, 0x7d, 0xbf, 0x46, 0xa7, 0x92, 0xc4,
        0x5e, 0x45, 0x49, 0x13, 0xfe, 0x2e, 0xa8, 0xf2
    },
    {
        0xa4, 0x4a, 0x82, 0x66, 0xee, 0x1c, 0x8e, 0xb0,
        0xc8, 0xb5, 0xd4, 0xcf, 0x5a, 0xe9, 0xf1, 0x9a
    },
};


/* AES CCM mode test data */
#define NB_TESTS 3

/*
 * The data is the same for all tests, only the used length changes
 */
static const unsigned char ccm_key[16] =
{
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
};

static const unsigned char ccm_iv[12] =
{
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b
};

static const unsigned char ccm_ad[20] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13
};

static const unsigned char ccm_msg[24] =
{
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
};

static const uint8_t ccm_iv_len [NB_TESTS] = { 7, 8,  12 };
static const uint32_t ccm_add_len[NB_TESTS] = { 8, 16, 20 };
static const uint32_t ccm_msg_len[NB_TESTS] = { 4, 16, 24 };
static const uint8_t ccm_tag_len[NB_TESTS] = { 4, 6,  8  };

static const unsigned char ccm_res[NB_TESTS][32] =
{
    {   0x71, 0x62, 0x01, 0x5b, 0x4d, 0xac, 0x25, 0x5d },
    {
        0xd2, 0xa1, 0xf0, 0xe0, 0x51, 0xea, 0x5f, 0x62,
        0x08, 0x1a, 0x77, 0x92, 0x07, 0x3d, 0x59, 0x3d,
        0x1f, 0xc6, 0x4f, 0xbf, 0xac, 0xcd
    },
    {
        0xe3, 0xb2, 0x01, 0xa9, 0xf5, 0xb7, 0x1a, 0x7a,
        0x9b, 0x1c, 0xea, 0xec, 0xcd, 0x97, 0xe7, 0x0b,
        0x61, 0x76, 0xaa, 0xd9, 0xa4, 0x42, 0x8a, 0xa5,
        0x48, 0x43, 0x92, 0xfb, 0xc1, 0xb0, 0x99, 0x51
    }
};


//Test Case AES-128 ECB swap test

static const unsigned char aes128_ecb_key_buf[16]  =
{
    0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
    0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
};

int         aes128_ecb_data_len         = 16 * 2;

/* original data */
uint32_t    aes128_ecb_clear_text[8]   =
{
    0x6bc1bee2, 0x2e409f96, 0xe93d7e11, 0x7393172a,
    0xae2d8a57, 0x1e03ac9c, 0x9eb76fac, 0x45af8e51
};
uint32_t    aes128_ecb_cipher_text[8]  =
{
    0x3ad77bb4, 0x0d7a3660, 0xa89ecaf3, 0x2466ef97,
    0xf5d3d585, 0x03b9699d, 0xe785895a, 0x96fdbaaf
};

/* half word swap */
uint32_t    aes128_ecb_clear_text1[8]   =
{
    0xbee26bc1, 0x9f962e40, 0x7e11e93d, 0x172a7393,
    0x8a57ae2d, 0xac9c1e03, 0x6fac9eb7, 0x8e5145af
};
uint32_t    aes128_ecb_cipher_text1[8] =
{
    0x7bb43ad7, 0x36600d7a, 0xcaf3a89e, 0xef972466,
    0xd585f5d3, 0x699d03b9, 0x895ae785, 0xbaaf96fd
};

/* 1 byte swap */
uint32_t    aes128_ecb_clear_text2[8]  =
{
    0xe2bec16b, 0x969f402e, 0x117e3de9, 0x2a179373,
    0x578a2dae, 0x9cac031e, 0xac6fb79e, 0x518eaf45
};
uint32_t    aes128_ecb_cipher_text2[8] =
{
    0xb47bd73a, 0x60367a0d, 0xf3ca9ea8, 0x97ef6624,
    0x85d5d3f5, 0x9d69b903, 0x5a8985e7, 0xafbafd96
};

/* bit swap */
uint32_t    aes128_ecb_clear_text3[64]  =
{
    0x477d83d6, 0x69f90274, 0x887ebc97, 0x54e8c9ce,
    0xea51b475, 0x3935c078, 0x35f6ed79, 0x8a71f5a2
};


uint32_t    aes128_ecb_cipher_text3[64] =
{
    0x2ddeeb5c, 0x066c5eb0, 0xcf537915, 0xe9f76624,
    0xa1abcbaf, 0xb9969dc0, 0x5a91a1e7, 0xf55dbf69
};


void AES_TestCallback(struct CRYP_Handle *hCryp, CRYP_Event_T event, unsigned long param)
{
    switch (event)
    {
        case CRYP_EVENT_INFIFO_TRANS_DONE:
            INFIFO_TRANS_DONE = TRUE;
            break;
        case CRYP_EVENT_OUTFIFO_TRANS_DONE:
            OUTFIFO_TRANS_DONE = TRUE;
            break;
        default:
            printk("unknown event.\n");
            break;
    }
}


/** AES ECB mode test */
int CRYP_AesEcbTest(CRYP_Handle_T *crypHandle, CRYP_Config_T *config)
{
    int ret = 0, i, u, v;
    uint8_t key[32];
    uint8_t buf[64];
    uint8_t buf_out[64];

    printk("AES ECB test start.\n");

    memset(config, 0, sizeof(CRYP_Config_T));
    config->algo = CRYP_ALGO_AES;
    config->algoMode = CRYP_ALGOMODE_ECB;
    config->dataType = CRYP_DATATYPE_8B;
    config->callback = AES_TestCallback;
#if DMA_MODE_TEST
    //DMA mode test
    config->enableDMA = TRUE;
#endif

#if 1
    config->keySel = CRYP_KEYFROM_REG;
#else
#if 1
    config->keySel = CRYP_KEYFROM_OTP;
    config->keyPos = CRYP_OTP_K0;
#else
    config->keySel = CRYP_KEYFROM_KEYBUF;
    config->keyPos = CRYP_KEYBUF_RD_K4;//CRYP_KEYBUF_RD_K0;
#endif
#endif

    //memcpy(key, aes_test_ecb_key, 16);

    for (i = 0; i < 6; i++)
    {
        u = i >> 1;
        v = i  & 1;
        printk("  AES-ECB-%3d (%s): \n", 128 + u * 64,
               (v == AES_DECRYPT) ? "dec" : "enc");
        //test for OTP and keybuffer
        //u = 2;

        switch (u)
        {
            case 0:
                config->keySize = CRYP_KEYSIZE_128B;
                memcpy(key, aes_test_ecb_key[0], 16);
                break;
            case 1:
                config->keySize = CRYP_KEYSIZE_192B;
                memcpy(key, aes_test_ecb_key[1], 24);
                break;
            default:
                config->keySize = CRYP_KEYSIZE_256B;
                memcpy(key, aes_test_ecb_key[2], 32);
                break;
        }
        config->pKey = key;
        HAL_CRYP_Init(crypHandle, config);

        if (v == AES_DECRYPT)
        {
            memcpy(buf, aes_test_ecb_dec[u], 64);

            HAL_CRYP_AES_Decrypt(crypHandle, buf, 64, buf_out);
            while (OUTFIFO_TRANS_DONE != TRUE)
            {
                HAL_DelayMs(1);
            }

            if (memcmp(buf_out, aes_test_ecb_plaintext, 64) != 0)
            {
                printk("  AES-ECB-%3d (%s): fail!\n", 128 + u * 64,
                       (v == AES_DECRYPT) ? "dec" : "enc");
                ret = -1;
                goto EXIT;
            }
            HAL_CRYP_DeInit(crypHandle);
        }
        else
        {
            memcpy(buf, aes_test_ecb_plaintext, 64);

            HAL_CRYP_AES_Encrypt(crypHandle, buf, 64, buf_out);
            while (OUTFIFO_TRANS_DONE != TRUE)
            {
                HAL_DelayMs(1);
            }

            if (memcmp(buf_out, aes_test_ecb_enc[u], 64) != 0)
            {
                printk("  AES-ECB-%3d (%s): fail!\n", 128 + u * 64,
                       (v == AES_DECRYPT) ? "dec" : "enc");
                ret = -2;
                goto EXIT;
            }
            HAL_CRYP_DeInit(crypHandle);
        }

        printk("  AES-ECB-%3d (%s): passed!\n", 128 + u * 64,
               (v == AES_DECRYPT) ? "dec" : "enc");
    }

EXIT:

    HAL_CRYP_DeInit(crypHandle);
    printk("AES ECB test done.\n");

    return ret;
}


/** AES CBC mode test */
int CRYP_AesCbcTest(CRYP_Handle_T *crypHandle, CRYP_Config_T *config)
{
    int ret = 0, i, u, v;
    uint8_t key[32];
    uint8_t buf[64];
    uint8_t buf_out[64];
    uint8_t iv[16];

    printk("AES CBC test start.\n");

    memset(config, 0, sizeof(CRYP_Config_T));
    config->algo = CRYP_ALGO_AES;
    config->algoMode = CRYP_ALGOMODE_CBC;
    config->dataType = CRYP_DATATYPE_8B;
    config->keySel = CRYP_KEYFROM_REG;
    config->callback = AES_TestCallback;
    memcpy(iv, aes_test_cbc_iv, 16);
    config->pInitVect = iv;
    config->IVSize = CRYP_VECTSIZE_128B;
#if DMA_MODE_TEST
    //DMA mode test
    config->enableDMA = TRUE;
#endif

    for (i = 0; i < 6; i++)
    {
        u = i >> 1;
        v = i  & 1;
        printk("  AES-CBC-%3d (%s): ", 128 + u * 64,
               (v == AES_DECRYPT) ? "dec" : "enc");

        switch (u)
        {
            case 0:
                config->keySize = CRYP_KEYSIZE_128B;
                memcpy(key, aes_test_cbc_key[0], 16);
                break;
            case 1:
                config->keySize = CRYP_KEYSIZE_192B;
                memcpy(key, aes_test_cbc_key[1], 24);
                break;
            default:
                config->keySize = CRYP_KEYSIZE_256B;
                memcpy(key, aes_test_cbc_key[2], 32);
                break;
        }
        config->pKey = key;
        HAL_CRYP_Init(crypHandle, config);

        if (v == AES_DECRYPT)
        {
            memcpy(buf, aes_test_cbc_dec[u], 64);
            HAL_CRYP_AES_Decrypt(crypHandle, buf, 64, buf_out);
            while (OUTFIFO_TRANS_DONE != TRUE)
            {
                HAL_DelayMs(1);
            }
            OUTFIFO_TRANS_DONE = FALSE;

            if (memcmp(buf_out, aes_test_cbc_plaintext, 64) != 0)
            {
                printk("  AES-CBC-%3d (%s): fail!\n", 128 + u * 64,
                       (v == AES_DECRYPT) ? "dec" : "enc");
                ret = -1;
                goto EXIT;
            }
            HAL_CRYP_DeInit(crypHandle);
        }
        else
        {
            memcpy(buf, aes_test_cbc_plaintext, 64);
            HAL_CRYP_AES_Encrypt(crypHandle, buf, 64, buf_out);
            while (OUTFIFO_TRANS_DONE != TRUE)
            {
                HAL_DelayMs(1);
            }
            OUTFIFO_TRANS_DONE = FALSE;

            if (memcmp(buf_out, aes_test_cbc_enc[u], 64) != 0)
            {
                printk("  AES-CBC-%3d (%s): fail!\n", 128 + u * 64,
                       (v == AES_DECRYPT) ? "dec" : "enc");
                ret = -2;
                goto EXIT;
            }
            HAL_CRYP_DeInit(crypHandle);
        }

        printk("  AES-CBC-%3d (%s): passed!\n", 128 + u * 64,
               (v == AES_DECRYPT) ? "dec" : "enc");
    }


EXIT:
    HAL_CRYP_DeInit(crypHandle);
    printk("AES CBC test done.\n");

    return 0;
}


/** AES CTR mode test */
int CRYP_AesCTRTest(CRYP_Handle_T *crypHandle, CRYP_Config_T *config)
{
    int ret = 0, i, u, v;
    uint8_t key[32];
    uint8_t buf[64];
    uint8_t buf_out[64];
    uint8_t iv[16];
    uint32_t len = 64;

    printk("AES CTR test start.\n");

    memset(config, 0, sizeof(CRYP_Config_T));
    config->algo = CRYP_ALGO_AES;
    config->algoMode = CRYP_ALGOMODE_CTR;
    config->dataType = CRYP_DATATYPE_8B;
    config->keySel = CRYP_KEYFROM_REG;
    config->callback = AES_TestCallback;
    memcpy(iv, aes_test_ctr_nonce_counter, 16);
    config->pInitVect = iv;
    config->IVSize = CRYP_VECTSIZE_128B;
#if DMA_MODE_TEST
    //DMA mode test
    config->enableDMA = TRUE;
#endif

    for (i = 0; i < 6; i++)
    {
        u = i >> 1;
        v = i  & 1;
        printk("  AES-CTR-%3d (%s): ", 128 + u * 64,
               (v == AES_DECRYPT) ? "dec" : "enc");

        switch (u)
        {
            case 0:
                config->keySize = CRYP_KEYSIZE_128B;
                memcpy(key, aes_test_ctr_key[0], 16);
                break;
            case 1:
                config->keySize = CRYP_KEYSIZE_192B;
                memcpy(key, aes_test_ctr_key[1], 24);
                break;
            default:
                config->keySize = CRYP_KEYSIZE_256B;
                memcpy(key, aes_test_ctr_key[2], 32);
                break;
        }
        config->pKey = key;
        HAL_CRYP_Init(crypHandle, config);

        if (v == AES_DECRYPT)
        {
            memcpy(buf, aes_test_ctr_dec[u], len);
            HAL_CRYP_AES_Decrypt(crypHandle, buf, len, buf_out);
            while (OUTFIFO_TRANS_DONE != TRUE)
            {
                HAL_DelayMs(1);
            }
            OUTFIFO_TRANS_DONE = FALSE;

            if (memcmp(buf_out, aes_test_ctr_plaintext, len) != 0)
            {
                printk("  AES-CTR-%3d (%s): fail!\n", 128 + u * 64,
                       (v == AES_DECRYPT) ? "dec" : "enc");
                ret = -1;
                goto EXIT;
            }
            HAL_CRYP_DeInit(crypHandle);
        }
        else
        {
            memcpy(buf, aes_test_ctr_plaintext, len);
            HAL_CRYP_AES_Encrypt(crypHandle, buf, len, buf_out);
            while (OUTFIFO_TRANS_DONE != TRUE)
            {
                HAL_DelayMs(1);
            }
            OUTFIFO_TRANS_DONE = FALSE;

            if (memcmp(buf_out, aes_test_ctr_enc[u], len) != 0)
            {
                printk("  AES-CTR-%3d (%s): fail!\n", 128 + u * 64,
                       (v == AES_DECRYPT) ? "dec" : "enc");
                ret = -2;
                goto EXIT;
            }
            HAL_CRYP_DeInit(crypHandle);
        }

        printk("  AES-CTR-%3d (%s): passed!\n", 128 + u * 64,
               (v == AES_DECRYPT) ? "dec" : "enc");
    }

EXIT:
    HAL_CRYP_DeInit(crypHandle);
    printk("AES CTR test done.\n");

    return 0;
}


/** AES GCM mode test */
int CRYP_AesGCMTest(CRYP_Handle_T *crypHandle, CRYP_Config_T *config)
{
    int ret = 0, i, j;
    static uint8_t tmp_data[64];
    uint8_t buf[64];
    unsigned char tag_buf[16];
    uint32_t len = 0;
    uint32_t key_len = 0;

    printk("AES GCM test start.\n");

    memset(config, 0, sizeof(CRYP_Config_T));
    config->algo = CRYP_ALGO_AES;
    config->algoMode = CRYP_ALGOMODE_GCM;
    config->dataType = CRYP_DATATYPE_8B;
    config->keySel = CRYP_KEYFROM_REG;
    config->callback = AES_TestCallback;
#if DMA_MODE_TEST
    //DMA mode test
    config->enableDMA = TRUE;
#endif

    for (j = 0; j < 3; j++)
    {
        key_len = 128 + j * 64;
        config->keySize = ((j == 0) ? CRYP_KEYSIZE_128B : ((j == 1) ? CRYP_KEYSIZE_192B : CRYP_KEYSIZE_256B));

        for (i = 0; i < MAX_TESTS; i++)
        {
            printk("  AES-GCM-%3d #%d (%s): \n",
                   key_len, i, "enc");
            config->header = additional[add_index[i]];
            config->headerSize = add_len[i];
            config->pInitVect = iv[iv_index[i]];
            config->IVSize = iv_len[i];
            config->pKey = key[key_index[i]];
            config->tagSize = 16;
            config->pScratch = (uint8_t *)malloc(16);
            HAL_CRYP_Init(crypHandle, config);

            /* DMA mode for padding case */
            memset(tmp_data, 0, sizeof(tmp_data));
            memcpy(tmp_data, pt[pt_index[i]], pt_len[i]);
            HAL_CRYP_AES_Encrypt(crypHandle, tmp_data, pt_len[i], buf);

            //HAL_CRYP_AES_Encrypt(crypHandle, pt[pt_index[i]], pt_len[i], buf);
            while ((pt_len[i] != 0) && (OUTFIFO_TRANS_DONE != TRUE))
            {
                HAL_DelayMs(1);
            }
            OUTFIFO_TRANS_DONE = FALSE;

            HAL_CRYP_AESGCM_Final(crypHandle, pt_len[i], tag_buf, 50);
            if (memcmp(buf, ct[j * 6 + i], pt_len[i]) != 0)
            {
                printk("  AES-GCM-%3d #%d (%s): encrypt fail.\n",
                       key_len, i, "enc");
                ret = -1;
                //goto EXIT;
            }
            if (memcmp(tag_buf, tag[j * 6 + i], 16) != 0)
            {
                printk("  AES-GCM-%3d #%d (%s): tag fail.\n",
                       key_len, i, "enc");
                ret = -2;
                //goto EXIT;
            }
            printk("  AES-GCM-%3d #%d (%s): success!\n",
                   key_len, i, "enc");
            free(config->pScratch);
            HAL_CRYP_DeInit(crypHandle);


            printk("  AES-GCM-%3d #%d (%s): \n",
                   key_len, i, "dec");
            config->header = additional[add_index[i]];
            config->headerSize = add_len[i];
            config->pInitVect = iv[iv_index[i]];
            config->IVSize = iv_len[i];
            config->pKey = key[key_index[i]];
            config->tagSize = 16;
            config->pScratch = (uint8_t *)malloc(16);
            HAL_CRYP_Init(crypHandle, config);

            /* DMA mode for padding case */
            memset(tmp_data, 0, sizeof(tmp_data));
            memcpy(tmp_data, ct[j * 6 + i], pt_len[i]);
            HAL_CRYP_AES_Decrypt(crypHandle, tmp_data, pt_len[i], buf);

            //HAL_CRYP_AES_Decrypt(crypHandle, ct[j * 6 + i], pt_len[i], buf);
            while ((pt_len[i] != 0) && (OUTFIFO_TRANS_DONE != TRUE))
            {
                HAL_DelayMs(1);
            }
            OUTFIFO_TRANS_DONE = FALSE;

            HAL_CRYP_AESGCM_Final(crypHandle, pt_len[i], tag_buf, 50);
            if (memcmp(buf, pt[pt_index[i]], pt_len[i]) != 0)
            {
                printk("  AES-GCM-%3d #%d (%s): Decrypt fail.\n",
                       key_len, i, "dec");
                ret = -1;
                //goto EXIT;
            }
            if (memcmp(tag_buf, tag[j * 6 + i], 16) != 0)
            {
                printk("  AES-GCM-%3d #%d (%s): tag fail.\n",
                       key_len, i, "dec");
                ret = -2;
                //goto EXIT;
            }
            printk("  AES-GCM-%3d #%d (%s): success!\n",
                   key_len, i, "dec");
            free(config->pScratch);
            HAL_CRYP_DeInit(crypHandle);
        }

    }

EXIT:
    free(config->pScratch);
    HAL_CRYP_DeInit(crypHandle);
    printk("AES GCM test done.\n");
    return ret;
}


/** AES CCM mode test */
int CRYP_AesCCMTest(CRYP_Handle_T *crypHandle, CRYP_Config_T *config)
{
    int ret = 0, i;
    uint8_t out[64];
    static uint8_t tmp_data[64];

    printk("AES CCM test start.\n");

    memset(config, 0, sizeof(CRYP_Config_T));
    config->algo = CRYP_ALGO_AES;
    config->algoMode = CRYP_ALGOMODE_CCM;
    config->dataType = CRYP_DATATYPE_8B;
    config->keySel = CRYP_KEYFROM_REG;
    config->callback = AES_TestCallback;
    config->keySize = CRYP_KEYSIZE_128B;
    config->pKey = ccm_key;
#if DMA_MODE_TEST
    //DMA mode test
    config->enableDMA = TRUE;
#endif

    for (i = 0; i < NB_TESTS; i++)
    {
        printk("  AES-CCM-128 #%d (%s): \n", i, "enc");
        config->IVSize = ccm_iv_len[i];
        config->pInitVect = ccm_iv;
        config->headerSize = ccm_add_len[i];
        config->header = ccm_ad;
        config->tagSize = ccm_tag_len[i];
        config->pScratch = (uint8_t *)malloc(config->headerSize + 21);
        memset(out, 0, sizeof(out));
        HAL_CRYP_Init(crypHandle, config);

        memset(tmp_data, 0, sizeof(tmp_data));
        memcpy(tmp_data, ccm_msg, ccm_msg_len[i]);
        HAL_CRYP_AES_Encrypt(crypHandle, tmp_data, ccm_msg_len[i], out);

        //HAL_CRYP_AES_Encrypt(crypHandle, ccm_msg, ccm_msg_len[i], out);
        while (OUTFIFO_TRANS_DONE != TRUE)
        {
            HAL_DelayMs(1);
        }
        OUTFIFO_TRANS_DONE = FALSE;

        HAL_CRYP_AESCCM_Final(crypHandle, out + ccm_msg_len[i], 5);
        if (memcmp(out, &ccm_res[i][0], ccm_msg_len[i] + ccm_tag_len[i]) != 0)
        {
            printk("  AES-CCM-128 #%d (%s): fail.\n", i, "enc");
            ret = -1;
            //goto EXIT;
        }
        printk("  AES-CCM-128 #%d (%s): success.\n", i, "enc");
        free(config->pScratch);
        HAL_CRYP_DeInit(crypHandle);

        printk("  AES-CCM-128 #%d (%s): \n", i, "dec");
        config->IVSize = ccm_iv_len[i];
        config->pInitVect = ccm_iv;
        config->headerSize = ccm_add_len[i];
        config->header = ccm_ad;
        config->tagSize = ccm_tag_len[i];
        config->pScratch = (uint8_t *)malloc(config->headerSize + 21);
        memset(out, 0, sizeof(out));
        HAL_CRYP_Init(crypHandle, config);

        memset(tmp_data, 0, sizeof(tmp_data));
        memcpy(tmp_data, &ccm_res[i][0], ccm_msg_len[i]);
        HAL_CRYP_AES_Decrypt(crypHandle, tmp_data, ccm_msg_len[i], out);

        //HAL_CRYP_AES_Decrypt(crypHandle, &ccm_res[i][0], ccm_msg_len[i], out);
        while (OUTFIFO_TRANS_DONE != TRUE)
        {
            HAL_DelayMs(1);
        }
        OUTFIFO_TRANS_DONE = FALSE;

        HAL_CRYP_AESCCM_Final(crypHandle, out + ccm_msg_len[i], 5);
        if (memcmp(out, ccm_msg, ccm_msg_len[i]) != 0)
        {
            printk("  AES-CCM-128 #%d (%s): encryp fail.\n", i, "dec");
            ret = -1;
            //goto EXIT;
        }
        if (memcmp(out + ccm_msg_len[i], ccm_res[i] + ccm_msg_len[i], ccm_tag_len[i]) != 0)
        {
            printk("  AES-CCM-128 #%d (%s): digest compare fail.\n", i, "dec");
            ret = -1;
            //goto EXIT;
        }
        printk("  AES-CCM-128 #%d (%s): success.\n", i, "dec");
        free(config->pScratch);
        HAL_CRYP_DeInit(crypHandle);
    }

EXIT:
    if (config->pScratch)
    {
        free(config->pScratch);
    }
    HAL_CRYP_DeInit(crypHandle);
    printk("AES CCM test done.\n");
    return 0;
}


int CRYP_AesEcbSwapTest(CRYP_Handle_T *crypHandle, CRYP_Config_T *config)
{
    int ret = 0, i, u, v;
    uint8_t key[32];
    uint8_t buf[64];
    uint8_t buf_out[64];


    printk("AES ECB swap test start.\n");

    memset(config, 0, sizeof(CRYP_Config_T));
    config->algo = CRYP_ALGO_AES;
    config->algoMode = CRYP_ALGOMODE_ECB;
    config->callback = AES_TestCallback;
    config->keySel = CRYP_KEYFROM_REG;
    config->keySize = CRYP_KEYSIZE_128B;
    memcpy(key, aes128_ecb_key_buf, 16);
    config->pKey = key;


    printk("  AES-ECB-128 half word swap: \n");

    config->dataType = CRYP_DATATYPE_16B;
    HAL_CRYP_Init(crypHandle, config);
    memcpy(buf, (uint8_t *)aes128_ecb_clear_text1, sizeof(aes128_ecb_clear_text1));
    HAL_CRYP_AES_Encrypt(crypHandle, buf, sizeof(aes128_ecb_clear_text1), buf_out);
    while (OUTFIFO_TRANS_DONE != TRUE)
    {
        HAL_DelayMs(1);
    }
    if (memcmp(buf_out, (uint8_t *)aes128_ecb_cipher_text1, sizeof(aes128_ecb_clear_text1)) != 0)
    {
        printk("  AES-ECB-128 half word swap: fail.\n");
        ret = -1;
        goto EXIT;
    }
    HAL_CRYP_DeInit(crypHandle);
    printk("  AES-ECB-128 half word swap: success.\n");


    printk("  AES-ECB-128 byte swap: \n");
    config->dataType = CRYP_DATATYPE_8B;
    HAL_CRYP_Init(crypHandle, config);
    memcpy(buf, (uint8_t *)aes128_ecb_cipher_text2, sizeof(aes128_ecb_cipher_text2));
    HAL_CRYP_AES_Decrypt(crypHandle, buf, sizeof(aes128_ecb_cipher_text2), buf_out);
    while (OUTFIFO_TRANS_DONE != TRUE)
    {
        HAL_DelayMs(1);
    }
    if (memcmp(buf_out, (uint8_t *)aes128_ecb_clear_text2, sizeof(aes128_ecb_clear_text2)) != 0)
    {
        printk("  AES-ECB-128 byte swap: fail.\n");
        ret = -1;
        goto EXIT;
    }
    HAL_CRYP_DeInit(crypHandle);
    printk("  AES-ECB-128 byte swap: success.\n");


EXIT:

    HAL_CRYP_DeInit(crypHandle);
    printk("AES ECB swap test done.\n");

    return ret;

}


